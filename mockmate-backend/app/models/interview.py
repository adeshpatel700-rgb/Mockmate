"""
app/models/interview.py

ğŸ§  WHAT THIS IS:
   Three related tables:
   1. InterviewSession â†’ One session (role, difficulty, final score)
   2. InterviewQuestion â†’ Questions asked in a session
   3. QuestionFeedback â†’ AI feedback for each question's answer

ğŸ“– DATABASE RELATIONSHIPS EXPLAINED:

   One-to-Many:
   One User â†’ Many Sessions
   One Session â†’ Many Questions
   One Question â†’ One Feedback

   Foreign Key:
   A column in Table B that points to the primary key of Table A.
   It's how you say "this session belongs to THIS user."
   
       users table         sessions table
       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       id (PK) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º user_id (FK)
       email               role
       name                difficulty

   Why not just put everything in one big table?
   "Normalization" â€” repeating user email in every session row is wasteful
   and inconsistent. Update the email once in users, it reflects everywhere.
"""

import uuid
from sqlalchemy import Column, String, Integer, Float, ForeignKey, Text, JSON
from sqlalchemy.orm import relationship

from app.db.session import Base
from app.models.base_model import TimestampMixin


class InterviewSession(Base, TimestampMixin):
    """
    Represents one complete interview session.
    
    A session is created when the user taps "Start Interview".
    It stores the configuration (role, difficulty) and the
    final aggregated score once all questions are answered.
    """

    __tablename__ = "interview_sessions"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))

    # Foreign key: links this session to its owner
    # ondelete="CASCADE" means deleting the user deletes their sessions at DB level
    user_id = Column(
        String(36),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True,  # Index for fast "get all sessions by user_id" queries
    )

    # Session configuration (mirrors what Flutter sends)
    role = Column(String(100), nullable=False)
    difficulty = Column(String(20), nullable=False)   # easy / intermediate / hard
    question_count = Column(Integer, nullable=False)

    # Aggregated result â€” calculated after all questions answered
    # Nullable because it's NULL until the session is complete
    final_score = Column(Float, nullable=True)
    is_completed = Column(String(10), default="false", nullable=False)

    # â”€â”€ Relationships â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Back-reference to the User who owns this session
    user = relationship("User", back_populates="sessions")

    # One session â†’ many questions
    questions = relationship(
        "InterviewQuestion",
        back_populates="session",
        cascade="all, delete-orphan",
        order_by="InterviewQuestion.order_index",  # Always return in order
    )

    def __repr__(self) -> str:
        return f"<InterviewSession id={self.id} role={self.role} score={self.final_score}>"


class InterviewQuestion(Base, TimestampMixin):
    """
    Represents a single question within a session.
    
    Why a separate table?
    A session has 3â€“10 questions. If we stored questions as a JSON
    array in the session row, we couldn't query individual questions
    efficiently. Separate table = proper indexing + querying.
    """

    __tablename__ = "interview_questions"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))

    # Foreign key to the session this question belongs to
    session_id = Column(
        String(36),
        ForeignKey("interview_sessions.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )

    # The question text generated by Groq AI
    question_text = Column(Text, nullable=False)

    # The user's typed answer (nullable â€” not answered yet when first created)
    user_answer = Column(Text, nullable=True)

    # Position in the session: 0, 1, 2, ... (for ordering)
    order_index = Column(Integer, nullable=False, default=0)

    # â”€â”€ Relationships â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    session = relationship("InterviewSession", back_populates="questions")

    # One question â†’ one feedback (nullable until answered + evaluated)
    feedback = relationship(
        "QuestionFeedback",
        back_populates="question",
        uselist=False,  # uselist=False = one-to-one (not a list)
        cascade="all, delete-orphan",
    )

    def __repr__(self) -> str:
        return f"<InterviewQuestion id={self.id} order={self.order_index}>"


class QuestionFeedback(Base, TimestampMixin):
    """
    AI-generated feedback for a single question's answer.
    
    Created after the user submits their answer and Groq AI
    evaluates it. One-to-one with InterviewQuestion.
    """

    __tablename__ = "question_feedback"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))

    # One-to-one with question
    question_id = Column(
        String(36),
        ForeignKey("interview_questions.id", ondelete="CASCADE"),
        nullable=False,
        unique=True,  # unique=True enforces the one-to-one constraint at DB level
        index=True,
    )

    # Groq AI evaluation results
    score = Column(Integer, nullable=False)                    # 0â€“100
    overall_feedback = Column(Text, nullable=False)           # 2â€“3 sentences
    strengths = Column(JSON, nullable=False, default=list)    # ["strength1", ...]
    improvements = Column(JSON, nullable=False, default=list) # ["improve1", ...]

    # â”€â”€ Relationships â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    question = relationship("InterviewQuestion", back_populates="feedback")

    def __repr__(self) -> str:
        return f"<QuestionFeedback question_id={self.question_id} score={self.score}>"
